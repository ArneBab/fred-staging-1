[1mdiff --git a/src/freenet/clients/http/ConnectionsToadlet.java b/src/freenet/clients/http/ConnectionsToadlet.java[m
[1mindex 43f4f00..b34bfc9 100644[m
[1m--- a/src/freenet/clients/http/ConnectionsToadlet.java[m
[1m+++ b/src/freenet/clients/http/ConnectionsToadlet.java[m
[36m@@ -22,7 +22,6 @@[m [mimport java.util.Map;[m
 import freenet.client.HighLevelSimpleClient;[m
 import freenet.clients.http.geoip.IPConverter;[m
 import freenet.clients.http.geoip.IPConverter.Country;[m
[31m-import freenet.darknetapp.DarknetAppServer;[m
 import freenet.io.comm.PeerParseException;[m
 import freenet.io.comm.ReferenceSignatureVerificationException;[m
 import freenet.io.xfer.PacketThrottle;[m
[36m@@ -51,10 +50,6 @@[m [mimport freenet.support.SizeUtil;[m
 import freenet.support.TimeUtil;[m
 import freenet.support.api.HTTPRequest;[m
 import freenet.support.io.Closer;[m
[31m-import java.io.File;[m
[31m-import java.io.FileInputStream;[m
[31m-import java.io.FileNotFoundException;[m
[31m-import java.util.Properties;[m
 [m
 /** Base class for DarknetConnectionsToadlet and OpennetConnectionsToadlet */[m
 public abstract class ConnectionsToadlet extends Toadlet {[m
[36m@@ -169,7 +164,7 @@[m [mpublic abstract class ConnectionsToadlet extends Toadlet {[m
 	protected final PeerManager peers;[m
 	protected boolean isReversed = false;[m
 	protected boolean showTrivialFoafConnections = false;[m
[31m-	private static int newTempDarknetRefs = 0;[m
[32m+[m
 	public enum PeerAdditionReturnCodes{ OK, WRONG_ENCODING, CANT_PARSE, INTERNAL_ERROR, INVALID_SIGNATURE, TRY_TO_ADD_SELF, ALREADY_IN_REFERENCE}[m
 [m
 	protected ConnectionsToadlet(Node n, NodeClientCore core, HighLevelSimpleClient client) {[m
[36m@@ -626,114 +621,8 @@[m [mpublic abstract class ConnectionsToadlet extends Toadlet {[m
 		[m
         if(!ctx.checkFullAccess(this))[m
             return;[m
[31m-            /**[m
[31m-            * Handle authorized/ rejected newly received references (from DarknetAppServer)[m
[31m-            * Put the code of adding references in a loop bounded by the total temporary references[m
[31m-            */[m
[31m-            if (request.isPartSet("addNew")) {[m
[31m-                    Properties prop = new Properties();[m
[31m-                    synchronized(DarknetAppServer.class) {[m
[31m-                        try {[m
[31m-                            File file =  new File(DarknetAppServer.filename);[m
[31m-                            prop.load(new FileInputStream(file));[m
[31m-                        } catch (FileNotFoundException ex) {[m
[31m-                            // Improbable to reach here.. [m
[31m-                            Logger.error(ctx, "Darknet App New Peers File Not Found",ex);[m
[31m-                            return;[m
[31m-                        } catch (IOException ex) {[m
[31m-                            return;[m
[31m-                        }[m
[31m-                    }[m
[31m-                    int addedNodes = 0;[m
[31m-                    Map<PeerAdditionReturnCodes,Integer> results=new HashMap<PeerAdditionReturnCodes, Integer>();[m
[31m-                    for(int i=1;i<=newTempDarknetRefs;i++) {[m
[31m-                        String auth = request.getPartAsStringFailsafe("auth"+i, 250).trim();[m
[31m-                        if (auth.equals("reject")) continue;[m
[31m-                        String privateComment = request.getPartAsStringFailsafe("peerPrivateNote"+i, 250).trim();[m
[31m-			String trustS = request.getPartAsStringFailsafe("trust"+i, 10);[m
[31m-			FRIEND_TRUST trust = null;[m
[31m-			if(trustS != null && !trustS.equals(""))[m
[31m-				trust = FRIEND_TRUST.valueOf(trustS);[m
[31m-			String visibilityS = request.getPartAsStringFailsafe("visibility"+i, 10);[m
[31m-			FRIEND_VISIBILITY visibility = null;[m
[31m-			if(visibilityS != null && !visibilityS.equals(""))[m
[31m-				visibility = FRIEND_VISIBILITY.valueOf(visibilityS);[m
[31m-			[m
[31m-			if(trust == null) {[m
[31m-				// FIXME: Layering violation. Ideally DarknetPeerNode would do this check.[m
[31m-				this.sendErrorPage(ctx, 200, l10n("noTrustLevelAddingFriendTitle"), l10n("noTrustLevelAddingFriend"), !isOpennet());[m
[31m-				return;[m
[31m-			}[m
[31m-			[m
[31m-			if(visibility == null) {[m
[31m-				// FIXME: Layering violation. Ideally DarknetPeerNode would do this check.[m
[31m-				this.sendErrorPage(ctx, 200, l10n("noVisibilityLevelAddingFriendTitle"), l10n("noVisibilityLevelAddingFriend"), !isOpennet());[m
[31m-				return;[m
[31m-			}[m
[31m-                             [m
[31m-                        String reftext = prop.getProperty("newPeer"+i);[m
[31m-                        StringBuilder ref = new StringBuilder(reftext.replaceAll(".*?((?:[\\w,\\.]+\\=[^\r\n]+?)|(?:End))[ \\t]*(?:\\r?\\n)+", "$1\n"));[m
[31m-                        ref = new StringBuilder(ref.toString().trim());[m
[31m-                        int idx;[m
[31m-			while((idx = ref.indexOf("\r\n")) > -1) {[m
[31m-				ref.deleteCharAt(idx);[m
[31m-			}[m
[31m-			while((idx = ref.indexOf("\r")) > -1) {[m
[31m-				// Mac's just use \r[m
[31m-				ref.setCharAt(idx, '\n');[m
[31m-			}[m
[31m-                        String nodeToAdd = ref.toString();[m
[31m-			String[] split = nodeToAdd.split("\n");       [m
[31m-                        StringBuffer sb = new StringBuffer(nodeToAdd.length());[m
[31m-                        boolean first = true;[m
[31m-                        for(String s : split) {[m
[31m-                                if(s.equals("End")) break;[m
[31m-                                if(s.indexOf('=') > -1) {[m
[31m-                                        if(!first)[m
[31m-                                                sb.append('\n');[m
[31m-                                } else {[m
[31m-                                        // Try appending it - don't add a newline.[m
[31m-                                        // This will make broken refs work sometimes.[m
[31m-                                }[m
[31m-                                sb.append(s);[m
[31m-                                first = false;[m
[31m-                        }[m
[31m-                        nodeToAdd = sb.toString();[m
[31m-                        PeerAdditionReturnCodes result=addNewNode(nodeToAdd.trim().concat("\nEnd"), privateComment, trust, visibility);[m
[31m-                        //Store the result[m
[31m-                               Integer prev = results.get(result);[m
[31m-                               if(prev == null) prev = Integer.valueOf(0);[m
[31m-                               results.put(result, prev+1);[m
[31m-                    }[m
[31m-                    PageNode page = ctx.getPageMaker().getPageNode(l10n("reportOfNodeAddition"), ctx);[m
[31m-                    HTMLNode pageNode = page.outer;[m
[31m-                    HTMLNode contentNode = page.content;[m
[31m-[m
[31m-                    //We create a table to show the results[m
[31m-                    HTMLNode detailedStatusBox=new HTMLNode("table");[m
[31m-                    //Header of the table[m
[31m-                    detailedStatusBox.addChild(new HTMLNode("tr")).addChildren(new HTMLNode[]{new HTMLNode("th",l10n("resultName")),new HTMLNode("th",l10n("numOfResults"))});[m
[31m-                    HTMLNode statusBoxTable=detailedStatusBox.addChild(new HTMLNode("tbody"));[m
[31m-                    //Iterate through the return codes[m
[31m-                    for(PeerAdditionReturnCodes returnCode:PeerAdditionReturnCodes.values()){[m
[31m-                            if(results.containsKey(returnCode)){[m
[31m-                                    //Add a <tr> and 2 <td> with the name of the code and the number of occasions it happened. If the code is OK, we use green, red elsewhere.[m
[31m-                                    statusBoxTable.addChild(new HTMLNode("tr","style","color:"+(returnCode==PeerAdditionReturnCodes.OK?"green":"red"))).addChildren(new HTMLNode[]{new HTMLNode("td",l10n("peerAdditionCode."+returnCode.toString())),new HTMLNode("td",results.get(returnCode).toString())});[m
[31m-                            }[m
[31m-                    }[m
[31m-[m
[31m-                    HTMLNode infoboxContent = ctx.getPageMaker().getInfobox("infobox",l10n("reportOfNodeAddition"), contentNode, "node-added", true);[m
[31m-                    infoboxContent.addChild(detailedStatusBox);[m
[31m-                    if(!isOpennet())[m
[31m-                            infoboxContent.addChild("p").addChild("a", "href", "/addfriend/", l10n("addAnotherFriend"));[m
[31m-                    infoboxContent.addChild("p").addChild("a", "href", path(), l10n("goFriendConnectionStatus"));[m
[31m-                    addHomepageLink(infoboxContent.addChild("p"));[m
[31m-                    synchronized(DarknetAppServer.class) {[m
[31m-                        DarknetAppServer.changeNewDarknetPeersCount(0, node);[m
[31m-                    }[m
[31m-                    writeHTMLReply(ctx, 500, l10n("reportOfNodeAddition"), pageNode.generate());[m
[31m-                }[m
[31m-            else if (request.isPartSet("add")) {[m
[32m+[m[41m        [m
[32m+[m		[32mif (request.isPartSet("add")) {[m
 			// add a new node[m
 			String urltext = request.getPartAsStringFailsafe("url", 200);[m
 			urltext = urltext.trim();[m
[36m@@ -1042,68 +931,7 @@[m [mpublic abstract class ConnectionsToadlet extends Toadlet {[m
 		}[m
 		peerAdditionForm.addChild("input", new String[] { "type", "name", "value" }, new String[] { "submit", "add", l10n("add") });[m
 	}[m
[31m-        /**[m
[31m-         * An infobox with a form to display all newly received references from darknetAppServer and ask user authorization[m
[31m-         * Ideally called by drawNodeRefBox i.e."add a friend" page [m
[31m-         * Can also be displayed on a separate toadlet if need be[m
[31m-         */[m
[31m-        protected static void drawNewDarknetPeersAuthBox(HTMLNode contentNode, ToadletContext ctx, boolean isOpennet, String formTarget) {[m
[31m-            if (isOpennet) return;[m
[31m-            HTMLNode newPeersInfobox = contentNode.addChild("div", "class", "infobox infobox-normal");[m
[31m-            newPeersInfobox.addChild("div", "class", "infobox-header", l10n("newPeersBoxTitle"));[m
[31m-            HTMLNode peerAdditionContent = newPeersInfobox.addChild("div", "class", "infobox-content");[m
[31m-            HTMLNode peerAdditionForm = ctx.addFormChild(peerAdditionContent, formTarget, "addPeerForm");[m
[31m-            synchronized (DarknetAppServer.class) {[m
[31m-                SimpleFieldSet fs = null;  [m
[31m-                Properties prop = new Properties();[m
[31m-                try {[m
[31m-                    File file =  new File(DarknetAppServer.filename);[m
[31m-                    prop.load(new FileInputStream(file));[m
[31m-                } catch (FileNotFoundException ex) {[m
[31m-                    Logger.error(ctx, "Darknet App New Peers File Not Found",ex);[m
[31m-                } catch (IOException ex) {[m
[31m-                    //File in Use..i.e. Synchronize with mobile is happening presently[m
[31m-                } [m
[31m-                newTempDarknetRefs = DarknetAppServer.newDarknetPeersCount;[m
[31m-                for (int i=1;i<=newTempDarknetRefs;i++) {[m
[31m-                    String noderef = prop.getProperty("newPeer"+i);[m
[31m-                    if (noderef==null || noderef.isEmpty()) continue;[m
[31m-                    peerAdditionForm.addChild("b", l10n("peerNodeReference"));[m
[31m-                    peerAdditionForm.addChild("pre", "id", "reference", noderef + '\n');[m
[31m-                    peerAdditionForm.addChild("b", l10n("AuthTitle"));[m
[31m-                    peerAdditionForm.addChild("#", " ");[m
[31m-                    peerAdditionForm.addChild("br").addChild("input", new String[] { "type", "name", "value" }, new String[] { "radio", "auth"+i, "authorize" }).addChild("b", l10n("auth"));;[m
[31m-                    peerAdditionForm.addChild("br").addChild("input", new String[] { "type", "name", "value" }, new String[] { "radio", "auth"+i, "reject" }).addChild("b", l10n("reject"));;	[m
[31m-                    peerAdditionForm.addChild("br");[m
[31m-                    peerAdditionForm.addChild("b", l10n("peerTrustTitle"));[m
[31m-                    peerAdditionForm.addChild("#", " ");[m
[31m-                    peerAdditionForm.addChild("#", l10n("peerTrustIntroduction"));[m
[31m-                    for(FRIEND_TRUST trust : FRIEND_TRUST.valuesBackwards()) { // FIXME reverse order[m
[31m-                            HTMLNode input = peerAdditionForm.addChild("br").addChild("input", new String[] { "type", "name", "value" }, new String[] { "radio", "trust"+i, trust.name() });[m
[31m-                            input.addChild("b", l10n("peerTrust."+trust.name())); // FIXME l10n[m
[31m-                            input.addChild("#", ": ");[m
[31m-                            input.addChild("#", l10n("peerTrustExplain."+trust.name()));[m
[31m-                    }[m
[31m-                    peerAdditionForm.addChild("br");[m
[31m-[m
[31m-                    peerAdditionForm.addChild("b", l10n("peerVisibilityTitle"));[m
[31m-                    peerAdditionForm.addChild("#", " ");[m
[31m-                    peerAdditionForm.addChild("#", l10n("peerVisibilityIntroduction"));[m
[31m-                    for(FRIEND_VISIBILITY trust : FRIEND_VISIBILITY.values()) { // FIXME reverse order[m
[31m-                            HTMLNode input = peerAdditionForm.addChild("br").addChild("input", new String[] { "type", "name", "value" }, new String[] { "radio", "visibility"+i, trust.name() });[m
[31m-                            input.addChild("b", l10n("peerVisibility."+trust.name())); // FIXME l10n[m
[31m-                            input.addChild("#", ": ");[m
[31m-                            input.addChild("#", l10n("peerVisibilityExplain."+trust.name()));[m
[31m-                    }[m
[31m-                    peerAdditionForm.addChild("br");[m
[31m-                    peerAdditionForm.addChild("#", (l10n("enterDescription") + ' '));[m
[31m-                    peerAdditionForm.addChild("input", new String[] { "id", "type", "name", "size", "maxlength", "value" }, new String[] { "peerPrivateNote", "text", "peerPrivateNote"+i, "16", "250", "" });[m
[31m-                    peerAdditionForm.addChild("br");[m
[31m-                }[m
[31m-                 peerAdditionForm.addChild("input", new String[] { "type", "name", "value" }, new String[] { "submit", "addNew", l10n("addNew") });[m
[31m-            }[m
[31m-        }[m
[31m-        [m
[32m+[m
 	protected Comparator<PeerNodeStatus> comparator(String sortBy, boolean reversed) {[m
 		return new ComparatorByStatus(sortBy, reversed);[m
 	}[m
[1mdiff --git a/src/freenet/clients/http/DarknetAddRefToadlet.java b/src/freenet/clients/http/DarknetAddRefToadlet.java[m
[1mindex 956509c..0c1d302 100644[m
[1m--- a/src/freenet/clients/http/DarknetAddRefToadlet.java[m
[1m+++ b/src/freenet/clients/http/DarknetAddRefToadlet.java[m
[36m@@ -5,7 +5,6 @@[m [mimport java.io.IOException;[m
 import java.net.URI;[m
 [m
 import freenet.client.HighLevelSimpleClient;[m
[31m-import freenet.darknetapp.DarknetAppServer;[m
 import freenet.l10n.NodeL10n;[m
 import freenet.node.Node;[m
 import freenet.node.updater.NodeUpdateManager;[m
[36m@@ -84,9 +83,7 @@[m [mpublic class DarknetAddRefToadlet extends Toadlet {[m
 		else[m
 			NodeL10n.getBase().addL10nSubstitution(p, "DarknetAddRefToadlet.explainInstallerNonWindowsNotYet", new String[] { "link", "shortfilename" }, new HTMLNode[] { HTMLNode.link("/"+node.nodeUpdater.getInstallerNonWindowsURI().toString()), HTMLNode.text(shortFilename) });[m
 			[m
[31m-		if (DarknetAppServer.newDarknetPeersCount>0)[m
[31m-                    ConnectionsToadlet.drawNewDarknetPeersAuthBox(contentNode, ctx, false, "/friends/");[m
[31m-                [m
[32m+[m[41m		[m
 		ConnectionsToadlet.drawAddPeerBox(contentNode, ctx, false, friendsToadlet.path());[m
 		[m
 		friendsToadlet.drawNoderefBox(contentNode, getNoderef(), pageMaker.advancedMode(request, this.container));[m
[1mdiff --git a/src/freenet/crypt/BCModifiedSSL.java b/src/freenet/crypt/BCModifiedSSL.java[m
[1mdeleted file mode 100644[m
[1mindex 224976c..0000000[m
[1m--- a/src/freenet/crypt/BCModifiedSSL.java[m
[1m+++ /dev/null[m
[36m@@ -1,288 +0,0 @@[m
[31m-/**[m
[31m- * SSL.java modified to use Bouncy Castle's implementation. Possibly, it can replace the outdated SSL.java[m
[31m- * Supports all functions of SSL.java including [m
[31m- * BCSSL.init() which stores/loads public key from node.crypt [m
[31m- * BCSSL.available() which says whether it is initialized[m
[31m- * In addition, BCSSL.getSelfSignedCertificatePin() returns the SHA256 hash of SPKI of the certificate. (also called pin)[m
[31m- */[m
[31m-package freenet.crypt;[m
[31m-[m
[31m-import freenet.config.InvalidConfigValueException;[m
[31m-import freenet.config.SubConfig;[m
[31m-import freenet.support.Logger;[m
[31m-import freenet.support.api.StringCallback;[m
[31m-import freenet.support.io.Closer;[m
[31m-[m
[31m-import java.io.File;[m
[31m-import java.io.FileInputStream;[m
[31m-import java.io.FileNotFoundException;[m
[31m-import java.io.FileOutputStream;[m
[31m-import java.io.IOException;[m
[31m-import java.math.BigInteger;[m
[31m-import java.net.ServerSocket;[m
[31m-import java.security.InvalidKeyException;[m
[31m-import java.security.Key;[m
[31m-import java.security.KeyManagementException;[m
[31m-import java.security.KeyPair;[m
[31m-import java.security.KeyPairGenerator;[m
[31m-import java.security.KeyStore;[m
[31m-import java.security.KeyStoreException;[m
[31m-import java.security.MessageDigest;[m
[31m-import java.security.NoSuchAlgorithmException;[m
[31m-import java.security.NoSuchProviderException;[m
[31m-import java.security.PrivateKey;[m
[31m-import java.security.SecureRandom;[m
[31m-import java.security.Security;[m
[31m-import java.security.SignatureException;[m
[31m-import java.security.UnrecoverableKeyException;[m
[31m-import java.security.cert.Certificate;[m
[31m-import java.security.cert.CertificateEncodingException;[m
[31m-import java.security.cert.CertificateException;[m
[31m-import java.security.cert.X509Certificate;[m
[31m-import java.util.Date;[m
[31m-import java.util.Formatter;[m
[31m-import java.util.logging.Level;[m
[31m-import javax.net.ServerSocketFactory;[m
[31m-import javax.net.ssl.KeyManagerFactory;[m
[31m-import javax.net.ssl.SSLContext;[m
[31m-import javax.security.auth.x500.X500Principal;[m
[31m-import org.bouncycastle.jce.provider.BouncyCastleProvider;[m
[31m-import org.bouncycastle.x509.X509V3CertificateGenerator;[m
[31m-[m
[31m-public class BCModifiedSSL {[m
[31m-    private static KeyStore keystore;[m
[31m-    private static ServerSocketFactory ssf;[m
[31m-    private static String keyStore;[m
[31m-    private static String keyStorePass;[m
[31m-    private static String keyPass;[m
[31m-    private static String CERTIFICATE_CHAIN_ALIAS = "freenet";[m
[31m-    static {[m
[31m-        Security.addProvider(new BouncyCastleProvider());[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-    * Call this function before ask ServerSocket[m
[31m-    * @return True is ssl is available[m
[31m-    */[m
[31m-    public static boolean available() {[m
[31m-		return (ssf != null);[m
[31m-    }[m
[31m-    /**[m
[31m-    * Copied from SSL.java[m
[31m-    * Configure SSL support[m
[31m-    * @param sslConfig[m
[31m-    */    [m
[31m-    public static void init(SubConfig sslConfig) {[m
[31m-        int configItemOrder = 0;[m
[31m-        sslConfig.register("sslKeyStore", "datastore/BCcerts", configItemOrder++, true, true, "SSL.keyStore", "SSL.keyStoreLong",[m
[31m-			new StringCallback() {[m
[31m-[m
[31m-				@Override[m
[31m-				public String get() {[m
[31m-					return keyStore;[m
[31m-				}[m
[31m-[m
[31m-				@Override[m
[31m-				public void set(String newKeyStore) throws InvalidConfigValueException {[m
[31m-					if(!newKeyStore.equals(get())) {[m
[31m-						String oldKeyStore = keyStore;[m
[31m-						keyStore = newKeyStore;[m
[31m-						try {[m
[31m-							loadKeyStore();[m
[31m-						} catch(Exception e) {[m
[31m-							keyStore = oldKeyStore;[m
[31m-							e.printStackTrace(System.out);[m
[31m-							throw new InvalidConfigValueException("Cannot change keystore file");[m
[31m-						}[m
[31m-					}[m
[31m-				}[m
[31m-			});[m
[31m-        sslConfig.register("sslKeyStorePass", "freenet", configItemOrder++, true, true, "SSL.keyStorePass", "SSL.keyStorePassLong",[m
[31m-			new StringCallback() {[m
[31m-[m
[31m-				@Override[m
[31m-				public String get() {[m
[31m-					return keyStorePass;[m
[31m-				}[m
[31m-[m
[31m-				@Override[m
[31m-				public void set(String newKeyStorePass) throws InvalidConfigValueException {[m
[31m-					if(!newKeyStorePass.equals(get())) {[m
[31m-						String oldKeyStorePass = keyStorePass;[m
[31m-						keyStorePass = newKeyStorePass;[m
[31m-						try {[m
[31m-							storeKeyStore();[m
[31m-						} catch(Exception e) {[m
[31m-							keyStorePass = oldKeyStorePass;[m
[31m-							e.printStackTrace(System.out);[m
[31m-							throw new InvalidConfigValueException("Cannot change keystore password");[m
[31m-						}[m
[31m-					}[m
[31m-				}[m
[31m-			});[m
[31m-[m
[31m-		sslConfig.register("sslKeyPass", "freenet", configItemOrder++, true, true, "SSL.keyPass", "SSL.keyPassLong",[m
[31m-			new StringCallback() {[m
[31m-[m
[31m-				@Override[m
[31m-				public String get() {[m
[31m-					return keyPass;[m
[31m-				}[m
[31m-[m
[31m-				@Override[m
[31m-				public void set(String newKeyPass) throws InvalidConfigValueException {[m
[31m-					if(!newKeyPass.equals(get())) {[m
[31m-						String oldKeyPass = keyPass;[m
[31m-						keyPass = newKeyPass;[m
[31m-						try {[m
[31m-							Certificate[] chain = keystore.getCertificateChain("freenet");[m
[31m-							Key privKey = keystore.getKey("freenet", oldKeyPass.toCharArray());[m
[31m-							keystore.setKeyEntry("freenet", privKey, keyPass.toCharArray(), chain);[m
[31m-							createSSLContext();[m
[31m-						} catch(Exception e) {[m
[31m-							keyPass = oldKeyPass;[m
[31m-							e.printStackTrace(System.out);[m
[31m-							throw new InvalidConfigValueException("Cannot change private key password");[m
[31m-						}[m
[31m-					}[m
[31m-				}[m
[31m-			});[m
[31m-        keyStore = sslConfig.getString("sslKeyStore");[m
[31m-		keyStorePass = sslConfig.getString("sslKeyStorePass");[m
[31m-		keyPass = sslConfig.getString("sslKeyPass");[m
[31m-        try {[m
[31m-            keystore = KeyStore.getInstance("PKCS12");[m
[31m-            loadKeyStore();[m
[31m-            createSSLContext();[m
[31m-        } catch(Exception e) {[m
[31m-            Logger.error(SSL.class, "Cannot load keystore, ssl is disable", e);[m
[31m-	}[m
[31m-        [m
[31m-    }[m
[31m-    /** [m
[31m-    * Create ServerSocket with ssl support[m
[31m-    * @return ServerSocket with ssl support[m
[31m-    * @throws IOException[m
[31m-    */[m
[31m-    public static ServerSocket createServerSocket() throws IOException {[m
[31m-        if(ssf == null)[m
[31m-            throw new IOException("SSL not initialized");[m
[31m-        return ssf.createServerSocket();[m
[31m-    }[m
[31m-	[m
[31m-    /**[m
[31m-    * Loads the keystore if it already exists. Otherwise, a self signed certificate is generated and stored[m
[31m-    */[m
[31m-    private static void loadKeyStore() throws NoSuchAlgorithmException, CertificateException, IOException, IllegalArgumentException, InstantiationException, IllegalAccessException, KeyStoreException, UnrecoverableKeyException, KeyManagementException, CertificateEncodingException, IllegalStateException, SignatureException, InvalidKeyException {[m
[31m-	// A keystore is where keys and certificates are kept[m
[31m-        // Both the keystore and individual private keys should be password protected[m
[31m-        FileInputStream fis = null;[m
[31m-	try {[m
[31m-            fis = new FileInputStream(keyStore);[m
[31m-            keystore.load(fis, keyStorePass.toCharArray());[m
[31m-        } catch(FileNotFoundException fnfe) {[m
[31m-            // If keystore not exist, create keystore and server certificate[m
[31m-            keystore.load(null, keyStorePass.toCharArray());[m
[31m-            try {[m
[31m-                Date start = new Date(System.currentTimeMillis());[m
[31m-                // One year in millis[m
[31m-                Date end = new Date(System.currentTimeMillis() + 365 * 24 * 60 * 60 * 1000); [m
[31m-                KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");[m
[31m-                keyPairGenerator.initialize(2048, new SecureRandom());[m
[31m-                KeyPair keyPair = keyPairGenerator.generateKeyPair();[m
[31m-                X509V3CertificateGenerator certGen;[m
[31m-                certGen = new X509V3CertificateGenerator();[m
[31m-                // "Freenet" is used as the SubjectDN, IssuerDN [m
[31m-                X500Principal name = new X500Principal("CN=Freenet");[m
[31m-                certGen.setSerialNumber(BigInteger.valueOf(System.currentTimeMillis()));[m
[31m-                certGen.setSubjectDN(name);[m
[31m-                certGen.setIssuerDN(name); // use the same[m
[31m-                certGen.setNotBefore(start);[m
[31m-                certGen.setNotAfter(end);[m
[31m-                certGen.setPublicKey(keyPair.getPublic());[m
[31m-                certGen.setSignatureAlgorithm("SHA256WithRSAEncryption");[m
[31m-                PrivateKey privKey = keyPair.getPrivate();    [m
[31m-                X509Certificate cert = certGen.generate(privKey, "BC");[m
[31m-                Certificate[] chain = new Certificate[1];[m
[31m-                chain[0] = cert;[m
[31m-                keystore.setKeyEntry(CERTIFICATE_CHAIN_ALIAS, privKey, keyPass.toCharArray(), chain);[m
[31m-                storeKeyStore();[m
[31m-                createSSLContext();[m
[31m-                } catch (NoSuchProviderException ex) {[m
[31m-                    throw new UnsupportedOperationException("BC not found!",ex);[m
[31m-                }[m
[31m-        } finally {[m
[31m-            Closer.close(fis);[m
[31m-        }[m
[31m-    }[m
[31m-	[m
[31m-    /**[m
[31m-    * Store the keystore into a file[m
[31m-    */[m
[31m-    private static void storeKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {[m
[31m-    	FileOutputStream fos = null;[m
[31m-        try {[m
[31m-        	File file = new File(keyStore);[m
[31m-        	File directory = file.getParentFile();[m
[31m-        	if(!directory.exists() && !directory.mkdirs()){[m
[31m-        	    throw new IllegalStateException("Couldn't create directory " + directory);[m
[31m-        	}[m
[31m-        	if (!file.exists()) file.createNewFile();[m
[31m-        	fos = new FileOutputStream(file);[m
[31m-                keystore.store(fos, keyStorePass.toCharArray());[m
[31m-        }[m
[31m-        catch (Exception e) {[m
[31m-        	e.printStackTrace();[m
[31m-        }[m
[31m-        finally {[m
[31m-            Closer.close(fos);[m
[31m-        }[m
[31m-    }[m
[31m-	[m
[31m-    /**[m
[31m-    * Copied from SSL.java[m
[31m-    */[m
[31m-    private static void createSSLContext() throws NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException, KeyManagementException {[m
[31m-        // A KeyManagerFactory is used to create key managers[m
[31m-        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");[m
[31m-        // Initialize the KeyManagerFactory to work with our keystore[m
[31m-        kmf.init(keystore, keyPass.toCharArray());[m
[31m-        // An SSLContext is an environment for implementing JSSE[m
[31m-        // It is used to create a ServerSocketFactory[m
[31m-        SSLContext sslc = SSLContext.getInstance("TLSv1");[m
[31m-        // Initialize the SSLContext to work with our key managers[m
[31m-        // FIXME: should we pass yarrow in here?[m
[31m-        sslc.init(kmf.getKeyManagers(), null, null);[m
[31m-        ssf = sslc.getServerSocketFactory();[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-    * Get the SHA256 hash of our self-signed certificate[m
[31m-    */[m
[31m-    public static String getSelfSignedCertificatePin() throws IOException {[m
[31m-        if (ssf==null)throw new IOException("SSL not initialized");[m
[31m-        String pin = "";[m
[31m-        try {    [m
[31m-            Certificate certificate = keystore.getCertificateChain(CERTIFICATE_CHAIN_ALIAS)[0];[m
[31m-            MessageDigest digest= null;[m
[31m-                try {    [m
[31m-                    digest = MessageDigest.getInstance("SHA256");[m
[31m-                }[m
[31m-                catch(NoSuchAlgorithmException e) {[m
[31m-                    e.printStackTrace();[m
[31m-                }[m
[31m-            final byte[] spki          = certificate.getPublicKey().getEncoded();[m
[31m-            final byte[] pinBytes           = digest.digest(spki);[m
[31m-            Formatter formatter = new Formatter();[m
[31m-            for (byte b : pinBytes)[m
[31m-            {[m
[31m-                formatter.format("%02x", b);[m
[31m-            }[m
[31m-            pin= formatter.toString();[m
[31m-            formatter.close();[m
[31m-        } catch (KeyStoreException ex) {[m
[31m-            java.util.logging.Logger.getLogger(BCModifiedSSL.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        }[m
[31m-        return pin;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/freenet/darknetapp/DarknetAppConnectionHandler.java b/src/freenet/darknetapp/DarknetAppConnectionHandler.java[m
[1mdeleted file mode 100644[m
[1mindex 59ffb93..0000000[m
[1m--- a/src/freenet/darknetapp/DarknetAppConnectionHandler.java[m
[1m+++ /dev/null[m
[36m@@ -1,149 +0,0 @@[m
[31m-/**[m
[31m- * Handles a socket connection with a mobile[m
[31m- * Use DarknetAppConnectionHandler.handle(socket)[m
[31m- * Target Application is to exchange nodereferences with mobile running our app[m
[31m- */[m
[31m-package freenet.darknetapp;[m
[31m-[m
[31m-import freenet.support.io.LineReadingInputStream;[m
[31m-import java.io.BufferedInputStream;[m
[31m-import java.io.File;[m
[31m-import java.io.FileInputStream;[m
[31m-import java.io.FileOutputStream;[m
[31m-import java.io.IOException;[m
[31m-import java.io.InputStream;[m
[31m-import java.io.OutputStream;[m
[31m-import java.net.Socket;[m
[31m-import java.util.Properties;[m
[31m-import java.util.logging.Level;[m
[31m-import java.util.logging.Logger;[m
[31m-[m
[31m-/**[m
[31m- *[m
[31m- * @author Illutionist[m
[31m- * [m
[31m- * Socket(SSL)communication instead of http communication[m
[31m- * To avoid unnecessary metadata as the only commands to support are push noderef and pull noderef [m
[31m- */[m
[31m-public class DarknetAppConnectionHandler {[m
[31m-    private Socket socket;[m
[31m-    private static String REQUEST_HOME_REFERENCE = "HomeReference";[m
[31m-    private static String REQUEST_PUSH_REFERENCE = "PushReference";[m
[31m-    private static String REQUEST_CLOSE_CONNECTION = "CloseConnection";[m
[31m-    private static String ASSERT_NODE_REFERENCES_RECEIVED = "ReceivedNodeReferences";[m
[31m-    private OutputStream out;[m
[31m-    private LineReadingInputStream input;[m
[31m-    private DarknetAppServer server;[m
[31m-    [m
[31m-    public DarknetAppConnectionHandler(Socket sock, DarknetAppServer server) {[m
[31m-      this.socket = sock; [m
[31m-      this.server = server;[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-     * Process a command (from the predefined set of commands). Connection would be closed immediately in case of wrong command[m
[31m-     * @param command REQUEST_HOME_REFERENCE - mobile requests home reference, REQUEST_PUSH_REFERENCE - mobile trying to push references[m
[31m-     * @param command ASSERT_NODE_REFERENCES_RECEIVED - We assert to the mobile that node references are received CLOSE_CONNECTION to close connection[m
[31m-     * @return[m
[31m-     * @throws IOException [m
[31m-     */[m
[31m-    private boolean process(String command) throws IOException {[m
[31m-        boolean done = false;[m
[31m-        if (command==null) return done;[m
[31m-        else if (command.equals(REQUEST_HOME_REFERENCE)) {[m
[31m-            out.write((DarknetAppServer.noderef+'\n').getBytes("UTF-8"));[m
[31m-            done = true;[m
[31m-        }[m
[31m-        else if (command.equals(REQUEST_PUSH_REFERENCE)) {[m
[31m-            int nFriendsRef = Integer.parseInt(input.readLine(32768, 128, true)); // Number of references the mobile is trying to push[m
[31m-            processNewRefernces(nFriendsRef);[m
[31m-            out.write((ASSERT_NODE_REFERENCES_RECEIVED+'\n').getBytes("UTF-8"));[m
[31m-            done = true;[m
[31m-        }     [m
[31m-        else if (command.equals(REQUEST_CLOSE_CONNECTION)) {            [m
[31m-            System.out.println("done");[m
[31m-            done = false;[m
[31m-        }[m
[31m-        return done;[m
[31m-    }[m
[31m-    // Extract input, output streams and get the request[m
[31m-    // Request is passed to process(String)[m
[31m-    public void processConnection() {[m
[31m-        try {[m
[31m-            InputStream is = new BufferedInputStream(socket.getInputStream(), 4096);[m
[31m-            input = new LineReadingInputStream(is);[m
[31m-            out = socket.getOutputStream();[m
[31m-            String command;[m
[31m-            boolean done = true;[m
[31m-            while (done) {[m
[31m-                // Null pointer handled in process function[m
[31m-                command = input.readLine(32768, 128, true);[m
[31m-                done = process(command);[m
[31m-            }[m
[31m-        } catch (IOException ex) {[m
[31m-            // Socket is closed whenever there is an IOException[m
[31m-            finish();[m
[31m-        }[m
[31m-[m
[31m-    }[m
[31m-    [m
[31m-    //Close connection and destroy everything[m
[31m-    public void finish() {[m
[31m-        try {[m
[31m-            if (socket!=null && !socket.isClosed()) {[m
[31m-                //socket.shutdownInput();[m
[31m-                //socket.shutdownOutput();[m
[31m-                socket.close();[m
[31m-            }[m
[31m-            if(input!=null) input.close();[m
[31m-            if (out!=null) out.close();[m
[31m-            //socket = null;[m
[31m-            input =null;[m
[31m-            out = null;[m
[31m-        } catch (IOException ex) {[m
[31m-            Logger.getLogger(DarknetAppConnectionHandler.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        }[m
[31m-    }[m
[31m-    [m
[31m-    // Entry Point. For each call(connection), an instance of this class is created and connection is handled[m
[31m-    public static void handle(Socket sock, DarknetAppServer server) {[m
[31m-        DarknetAppConnectionHandler context = new DarknetAppConnectionHandler(sock,server);[m
[31m-        context.processConnection();[m
[31m-        context.finish();[m
[31m-    }[m
[31m-    [m
[31m-    /** New references pushed by mobile are handled here[m
[31m-     *  We accept anything below 50 lines as a reference at this stage. Checking the validity is left to the parsing abilities at connections toadlet[m
[31m-     *  Properies file is used to store temporarynoderefs because apparently SimpleFieldSet cannot handle new lines and too lazy to store/process in plain text[m
[31m-     *  The temporary noderefs are loaded by the "add a friend" page (DarknetAddRefToadlet.java) to be authorized by the user. [m
[31m-     *  Once the user authorizes or rejects, they are deleted[m
[31m-     */[m
[31m-    private void processNewRefernces(int nFriendsRefs) throws IOException {[m
[31m-        System.out.println("command" + nFriendsRefs);[m
[31m-        synchronized(DarknetAppServer.class) {[m
[31m-            //hold lock to make sure that file is opened only here at this point of time[m
[31m-            File file = new File(DarknetAppServer.filename);[m
[31m-            Properties prop = new Properties();[m
[31m-            prop.load(new FileInputStream(file));[m
[31m-            int iniCount = DarknetAppServer.newDarknetPeersCount;[m
[31m-            int finCount = iniCount+nFriendsRefs;[m
[31m-            for (int i=iniCount+1; i<=finCount; i++) {[m
[31m-                int maxLinesPerRef = 50;[m
[31m-                String noderef = "";[m
[31m-                int count = 0;[m
[31m-                String readLine;[m
[31m-		while (!(readLine = input.readLine(32768, 128, true)).isEmpty()) {[m
[31m-                    noderef = noderef.concat(readLine+'\n');[m
[31m-                    count++;[m
[31m-                    if (count>maxLinesPerRef) throw new IOException();[m
[31m-                }            [m
[31m-                prop.setProperty("newPeer"+i, noderef);[m
[31m-                System.out.println("newPeer"+i+"added");[m
[31m-            }[m
[31m-            prop.store(new FileOutputStream(new File(DarknetAppServer.filename)), null);[m
[31m-            System.out.println(DarknetAppServer.filename+finCount);[m
[31m-            server.changeNewDarknetPeersCount(finCount);[m
[31m-        }[m
[31m-    }[m
[31m-          [m
[31m-}[m
[1mdiff --git a/src/freenet/darknetapp/DarknetAppServer.java b/src/freenet/darknetapp/DarknetAppServer.java[m
[1mdeleted file mode 100644[m
[1mindex 5783f04..0000000[m
[1m--- a/src/freenet/darknetapp/DarknetAppServer.java[m
[1m+++ /dev/null[m
[36m@@ -1,396 +0,0 @@[m
[31m-/**[m
[31m- * A server to communicate with darknet app on mobiles on the lines of SimpleToadletServer[m
[31m- */[m
[31m-package freenet.darknetapp;[m
[31m-[m
[31m-import freenet.config.InvalidConfigValueException;[m
[31m-import freenet.config.NodeNeedRestartException;[m
[31m-import freenet.config.SubConfig;[m
[31m-import freenet.crypt.BCModifiedSSL;[m
[31m-import freenet.io.BCSSLNetworkInterface;[m
[31m-import freenet.io.NetworkInterface;[m
[31m-import freenet.l10n.NodeL10n;[m
[31m-import freenet.node.Node;[m
[31m-import freenet.node.PrioRunnable;[m
[31m-import freenet.support.Executor;[m
[31m-import freenet.support.LogThresholdCallback;[m
[31m-import freenet.support.Logger;[m
[31m-import freenet.support.Logger.LogLevel;[m
[31m-import freenet.support.OOMHandler;[m
[31m-import freenet.support.api.BooleanCallback;[m
[31m-import freenet.support.api.IntCallback;[m
[31m-import freenet.support.api.StringCallback;[m
[31m-import freenet.support.io.NativeThread;[m
[31m-import java.io.File;[m
[31m-import java.io.IOException;[m
[31m-import java.net.Socket;[m
[31m-import java.net.SocketException;[m
[31m-import java.util.Arrays;[m
[31m-import java.util.logging.Level;[m
[31m-import org.tanukisoftware.wrapper.WrapperManager;[m
[31m-[m
[31m-[m
[31m-/**[m
[31m- * @author Illutionist[m
[31m- * TODO: A general server base class that extends to SimpleToadletServer, FCPServer, DarknetAppServer etc.[m
[31m- *       Many functions are rewritten in this implementation as SimpleToadletServer was linked heavily with fproxy [m
[31m- */[m
[31m-public class DarknetAppServer implements Runnable {[m
[31m-    private boolean enabled = true;[m
[31m-    private final int DEFAULT_PORT = 7859; [m
[31m-    private String allowedHosts;[m
[31m-    private String bindTo;[m
[31m-    private int port = DEFAULT_PORT;[m
[31m-    private Thread myThread;[m
[31m-    private final Executor executor;[m
[31m-    private Node node;[m
[31m-    private NetworkInterface networkInterface;[m
[31m-    private int maxDarknetAppConnections =10;	[m
[31m-    private int darknetAppConnections;[m
[31m-    private boolean finishedStartup;[m
[31m-    public static String noderef;[m
[31m-    [m
[31m-    // Newly exchanged peers that are neither accepted nor rejected[m
[31m-    public static int newDarknetPeersCount = 0;[m
[31m-    [m
[31m-    public static String filename = "TempPeersFromDarknetApp.prop";[m
[31m-    private static volatile boolean logMINOR;[m
[31m-	static {[m
[31m-            Logger.registerLogThresholdCallback(new LogThresholdCallback(){[m
[31m-                    @Override[m
[31m-                    public void shouldUpdate(){[m
[31m-                            logMINOR = Logger.shouldLog(LogLevel.MINOR, this);[m
[31m-                    }[m
[31m-            });[m
[31m-	}[m
[31m-    public boolean isEnabled() {[m
[31m-        return myThread != null;[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-     *  To be called by the node[m
[31m-     */[m
[31m-    public void start() {[m
[31m-        if (!enabled) return;[m
[31m-        if(myThread != null) {[m
[31m-            try {[m
[31m-                maybeGetNetworkInterface(true);[m
[31m-            } catch (IOException ex) {[m
[31m-                java.util.logging.Logger.getLogger(DarknetAppServer.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-                return;[m
[31m-            }[m
[31m-                myThread.start();[m
[31m-                Logger.normal(this, "Starting DarknetAppServer on "+bindTo+ ':' +port);[m
[31m-                System.out.println("Starting DarknetAppServer on "+bindTo+ ':' +port);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    public DarknetAppServer(SubConfig darknetAppConfig, Node node, Executor executor) {[m
[31m-        this.executor = executor;[m
[31m-        this.node = node;[m
[31m-        int configItemOrder = 0;[m
[31m-   [m
[31m-        //  allowedHosts - "*" to allow all, bindTo - "0.0.0.0" to accept on all interfaces[m
[31m-        darknetAppConfig.register("newDarknetPeersCount",0, configItemOrder++, true, true, "DarknetAppServer.newPeersCount", "DarknetAppServer.newPeersCountLong",[m
[31m-				new newDarknetPeersCallback(), false);[m
[31m-        DarknetAppServer.newDarknetPeersCount = darknetAppConfig.getInt("newDarknetPeersCount");[m
[31m-        darknetAppConfig.register("enabled", true, configItemOrder++, true, true, "DarknetAppServer.enabled", "DarknetAppServer.enabledLong",[m
[31m-				new  darknetAppEnabledCallback());[m
[31m-        this.enabled = darknetAppConfig.getBoolean("enabled");[m
[31m-        darknetAppConfig.register("port", DEFAULT_PORT, configItemOrder++, true, true, "DarknetAppServer.port", "DarknetAppServer.portLong",[m
[31m-				new darknetAppPortCallback(), false);[m
[31m-        this.port = darknetAppConfig.getInt("port");[m
[31m-        darknetAppConfig.register("allowedHosts", "*", configItemOrder++, true, true, "DarknetAppServer.allowedHosts", "DarknetAppServer.allowedHostsLong", [m
[31m-                                new  darknetAppAllowedHostsCallback());				[m
[31m-        this.allowedHosts = darknetAppConfig.getString("allowedHosts");[m
[31m-        darknetAppConfig.register("bindTo", "0.0.0.0", configItemOrder++, true, true, "DarknetAppServer.bindTo", "DarknetAppServer.bindToLong",[m
[31m-				new darknetAppBindtoCallback());[m
[31m-        this.bindTo = darknetAppConfig.getString("bindTo"); [m
[31m-        try {[m
[31m-            //always enable SSL - false to use plaintext[m
[31m-            maybeGetNetworkInterface(true);[m
[31m-        } catch (IOException ex) {[m
[31m-            java.util.logging.Logger.getLogger(DarknetAppServer.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-            return;[m
[31m-        }[m
[31m-        configureFile();[m
[31m-        if (!enabled) {[m
[31m-            myThread=null;[m
[31m-        }[m
[31m-        else {[m
[31m-            myThread = new Thread(this, "DarknetAppServer");[m
[31m-            myThread.setDaemon(true);[m
[31m-        }[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-     * A properties file that stores the temporary node references[m
[31m-     * These references are yet to be approved by the node[m
[31m-     * As soon as user takes an action about these new peers, their reference would be removed[m
[31m-     */[m
[31m-    private void configureFile() {[m
[31m-        File file = new File(filename);[m
[31m-        if (!file.exists()) try {[m
[31m-            file.createNewFile();[m
[31m-        } catch (IOException ex) {[m
[31m-            Logger.error(this,"Error Creating File To Save Excahnged Nodereferences"+ex);[m
[31m-        }[m
[31m-    }[m
[31m-    public synchronized void changeNewDarknetPeersCount(int count) {[m
[31m-        changeNewDarknetPeersCount(count,node);[m
[31m-    }[m
[31m-    /**[m
[31m-     * To change the temporary peers count. Mostly used by DarknetAppConnectionhandler and ConnectionsToadlet[m
[31m-     * @param count[m
[31m-     * @param node [m
[31m-     */[m
[31m-    public static void changeNewDarknetPeersCount(int count,Node node) {[m
[31m-        try {[m
[31m-            SubConfig darknetAppConfig = node.config.get("darknetApp");[m
[31m-            darknetAppConfig.set("newDarknetPeersCount", String.valueOf(count));[m
[31m-            node.config.store();[m
[31m-            newDarknetPeersCount = count;[m
[31m-            Logger.normal(DarknetAppServer.class,"Unsynchronized Peers Count" +darknetAppConfig.getInt("newDarknetPeersCount"));[m
[31m-        } catch (InvalidConfigValueException ex) {[m
[31m-            java.util.logging.Logger.getLogger(DarknetAppServer.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (NodeNeedRestartException ex) {[m
[31m-            java.util.logging.Logger.getLogger(DarknetAppServer.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        }[m
[31m-    }[m
[31m-    [m
[31m-    //Modified from SimpleToadletServer to use BCSSLNetworkInterface instead of SSLNetworkInterface[m
[31m-    private void maybeGetNetworkInterface(boolean ssl) throws IOException {[m
[31m-        if (this.networkInterface!=null) return;[m
[31m-        if(ssl) {[m
[31m-            if (!BCModifiedSSL.available()) throw new IOException();[m
[31m-            Logger.normal(this,"Certificate Pin-->>" + BCModifiedSSL.getSelfSignedCertificatePin());[m
[31m-            System.out.println("Certificate Pin-->>" + BCModifiedSSL.getSelfSignedCertificatePin());[m
[31m-            this.networkInterface = BCSSLNetworkInterface.create(port, this.bindTo, allowedHosts, executor, false);[m
[31m-        } else {[m
[31m-            this.networkInterface = NetworkInterface.create(port, this.bindTo, allowedHosts, executor, true);[m
[31m-        }[m
[31m-    }[m
[31m-    [m
[31m-    public void finishStart() {[m
[31m-        synchronized(DarknetAppServer.class) {                [m
[31m-            //TODO: Change this [m
[31m-            this.noderef = node.exportDarknetPublicFieldSet().toString();[m
[31m-            finishedStartup = true;[m
[31m-        }[m
[31m-    }[m
[31m-    /**[m
[31m-     * This is necessary to be in the config for advanced users.[m
[31m-     * In case of an attack where our homeNode is bombarded with new references, the user can shift this to 0 and/or disable this server (using other config option)[m
[31m-     * Unnecessary changing of this value might cause instability in this app and/or losing temporary peer node references and so for advanced users[m
[31m-     */[m
[31m-    private class newDarknetPeersCallback extends IntCallback {[m
[31m-        @Override[m
[31m-        public Integer get() {[m
[31m-            return newDarknetPeersCount;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void set(Integer val) throws InvalidConfigValueException, NodeNeedRestartException {[m
[31m-            synchronized(DarknetAppServer.class) {[m
[31m-                newDarknetPeersCount = val;[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-    [m
[31m-    // Copied from SimpleToadletServer[m
[31m-    private class darknetAppBindtoCallback extends StringCallback  {[m
[31m-            @Override[m
[31m-            public String get() {[m
[31m-                    return bindTo;[m
[31m-            }[m
[31m-[m
[31m-            @Override[m
[31m-            public void set(String bindTo) throws InvalidConfigValueException {[m
[31m-                    String oldValue = get();[m
[31m-                    if(!bindTo.equals(oldValue)) {[m
[31m-                            String[] failedAddresses = networkInterface.setBindTo(bindTo, false);[m
[31m-                            if(failedAddresses == null) {[m
[31m-                                    DarknetAppServer.this.bindTo = bindTo;[m
[31m-                            } else {[m
[31m-                                    // This is an advanced option for reasons of reducing clutter,[m
[31m-                                    // but it is expected to be used by regular users, not devs.[m
[31m-                                    // So we translate the error messages.[m
[31m-                                    networkInterface.setBindTo(oldValue, false);[m
[31m-                                    throw new InvalidConfigValueException(l10n("couldNotChangeBindTo", "failedInterfaces", Arrays.toString(failedAddresses)));[m
[31m-                            }[m
[31m-                    }[m
[31m-            }[m
[31m-    }[m
[31m-    [m
[31m-    // Copied from SimpleToadletServer[m
[31m-    private class darknetAppAllowedHostsCallback extends StringCallback  {[m
[31m-            @Override[m
[31m-            public String get() {[m
[31m-                    return networkInterface.getAllowedHosts();[m
[31m-            }[m
[31m-[m
[31m-            @Override[m
[31m-            public void set(String allowedHosts) throws InvalidConfigValueException {[m
[31m-                    if (!allowedHosts.equals(get())) {[m
[31m-                            try {[m
[31m-                            networkInterface.setAllowedHosts(allowedHosts);[m
[31m-                            } catch(IllegalArgumentException e) {[m
[31m-                                    throw new InvalidConfigValueException(e);[m
[31m-                            }[m
[31m-                    }[m
[31m-            }[m
[31m-    }[m
[31m-    /**[m
[31m-     * When an advanced user changes port, the server is restarted on the fly[m
[31m-     * Although, the MDNS plugin might have to be restarted as it would still be broadcasting the old port[m
[31m-     */[m
[31m-    private class darknetAppPortCallback extends IntCallback  {[m
[31m-        @Override[m
[31m-        public Integer get() {[m
[31m-                return port;[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public void set(Integer newPort) throws NodeNeedRestartException {[m
[31m-                if(port != newPort) {[m
[31m-                      port = newPort;[m
[31m-                      try {[m
[31m-                          maybeGetNetworkInterface(true);[m
[31m-                      }[m
[31m-                      catch (IOException e) {[m
[31m-                          Logger.error(this,"Error while changing port",e);[m
[31m-                      }[m
[31m-                      if (enabled) {[m
[31m-                          synchronized(DarknetAppServer.class) {[m
[31m-                               myThread.interrupt();[m
[31m-                               myThread = new Thread(DarknetAppServer.this, "DarknetAppServer");[m
[31m-                               myThread.setDaemon(true);[m
[31m-                               myThread.start();[m
[31m-                               Logger.normal(this,"Restarting DarknetAppServer on "+bindTo+ ':' +port);[m
[31m-                          }[m
[31m-                      }[m
[31m-                }[m
[31m-        }[m
[31m-    }[m
[31m-    /**[m
[31m-     * Allows on the fly enabling and disabling[m
[31m-     */[m
[31m-    private class darknetAppEnabledCallback extends BooleanCallback  {[m
[31m-        @Override[m
[31m-        public Boolean get() {[m
[31m-                synchronized(DarknetAppServer.class) {[m
[31m-                        return myThread != null;[m
[31m-                }[m
[31m-        }[m
[31m-        @Override[m
[31m-        public void set(Boolean val) throws InvalidConfigValueException {[m
[31m-                if (get().equals(val))[m
[31m-                        return;[m
[31m-                synchronized(DarknetAppServer.class) {[m
[31m-                        if(val) {[m
[31m-                                // Start it[m
[31m-                                enabled = true;[m
[31m-                                System.out.println("Starting DarknetAppServer on "+bindTo+ ':' +port);[m
[31m-                                myThread = new Thread(DarknetAppServer.this, "DarknetAppServer");[m
[31m-                        } else {[m
[31m-                                enabled = false;[m
[31m-                                myThread.interrupt();[m
[31m-                                myThread = null;[m
[31m-                                System.out.println("Closing DarknetAppServer on "+bindTo+ ':' +port);[m
[31m-                                return;[m
[31m-                        }[m
[31m-                }[m
[31m-                myThread.setDaemon(true);[m
[31m-                myThread.start();[m
[31m-        }[m
[31m-    }[m
[31m-    [m
[31m-    private static String l10n(String key, String pattern, String value) {[m
[31m-        return NodeL10n.getBase().getString("DarknetAppServer."+key, pattern, value);[m
[31m-    }[m
[31m-    [m
[31m-    @Override[m
[31m-    public void run() {[m
[31m-    	if (networkInterface==null) {[m
[31m-    		Logger.error(this, "Could not start DarknetAppServer");[m
[31m-                System.err.println("Could not start DarknetAppServer");[m
[31m-    		return;[m
[31m-    	}[m
[31m-        try {[m
[31m-            networkInterface.setSoTimeout(500);[m
[31m-	} catch (SocketException e1) {[m
[31m-            Logger.error(this, "Could not set so-timeout to 500ms; on-the-fly disabling of the interface will not work");[m
[31m-	}[m
[31m-    boolean finishedStartup = false;[m
[31m-    while(true) {[m
[31m-        synchronized(DarknetAppServer.class) {[m
[31m-                while(darknetAppConnections > maxDarknetAppConnections) {[m
[31m-                        try {[m
[31m-                            wait();[m
[31m-                        } catch (InterruptedException e) {[m
[31m-                                // Ignore[m
[31m-                        }[m
[31m-                }[m
[31m-                if((!finishedStartup) && this.finishedStartup)[m
[31m-                        finishedStartup = true;[m
[31m-                if(myThread == null) return;[m
[31m-        }[m
[31m-        Socket conn = networkInterface.accept();[m
[31m-        if (WrapperManager.hasShutdownHookBeenTriggered())[m
[31m-                return;[m
[31m-        if(conn == null)[m
[31m-            continue; // timeout[m
[31m-        if(logMINOR)[m
[31m-            Logger.minor(this, "Accepted connection");[m
[31m-        SocketHandler sh = new SocketHandler(conn, finishedStartup);[m
[31m-        sh.start();[m
[31m-        }[m
[31m-    }[m
[31m-    //Modified to suit needs from SimpleToadletServer[m
[31m-    public class SocketHandler implements PrioRunnable {[m
[31m-        Socket sock;[m
[31m-        final boolean finishedStartup;[m
[31m-[m
[31m-        public SocketHandler(Socket conn, boolean finishedStartup) {[m
[31m-                this.sock = conn;[m
[31m-                this.finishedStartup = finishedStartup;[m
[31m-        }[m
[31m-[m
[31m-        // A thread starts for each accepted socket connection[m
[31m-        void start() {[m
[31m-            new Thread(this).start();[m
[31m-            synchronized(DarknetAppServer.class) {[m
[31m-                darknetAppConnections++;[m
[31m-            }   [m
[31m-        }[m
[31m-        [m
[31m-        @Override[m
[31m-        public void run() {[m
[31m-            freenet.support.Logger.OSThread.logPID(this);[m
[31m-                if(logMINOR) Logger.minor(this, "Handling connection");[m
[31m-                try {[m
[31m-                    // Handle request here[m
[31m-                    DarknetAppConnectionHandler.handle(sock,DarknetAppServer.this);[m
[31m-                } catch (OutOfMemoryError e) {[m
[31m-                        OOMHandler.handleOOM(e);[m
[31m-                        System.err.println("SimpleToadletServer request above failed.");[m
[31m-                        Logger.error(this, "OOM in SocketHandler");[m
[31m-                } catch (Throwable t) {[m
[31m-                        System.err.println("Caught in SimpleToadletServer: "+t);[m
[31m-                        t.printStackTrace();[m
[31m-                        Logger.error(this, "Caught in SimpleToadletServer: "+t, t);[m
[31m-                } finally {[m
[31m-                    synchronized(DarknetAppServer.class) {[m
[31m-                        darknetAppConnections--;[m
[31m-                        DarknetAppServer.class.notifyAll();[m
[31m-                    }[m
[31m-                }[m
[31m-                if(logMINOR) Logger.minor(this, "Handled connection");[m
[31m-        }[m
[31m-[m
[31m-        @Override[m
[31m-        public int getPriority() {[m
[31m-                return NativeThread.HIGH_PRIORITY-1;[m
[31m-        }[m
[31m-    }   [m
[31m-}[m
\ No newline at end of file[m
[1mdiff --git a/src/freenet/darknetapp/ECDSA.java b/src/freenet/darknetapp/ECDSA.java[m
[1mdeleted file mode 100644[m
[1mindex 080320d..0000000[m
[1m--- a/src/freenet/darknetapp/ECDSA.java[m
[1m+++ /dev/null[m
[36m@@ -1,206 +0,0 @@[m
[31m-/**[m
[31m- * Elliptical Curve DSA implementation from BouncyCastle[m
[31m- * TODO: Store in node.crypt instead of using properties file[m
[31m- */[m
[31m-package freenet.darknetapp;[m
[31m-[m
[31m-[m
[31m-import java.io.File;[m
[31m-import java.io.FileInputStream;[m
[31m-import java.io.FileOutputStream;[m
[31m-import java.io.IOException;[m
[31m-import java.io.UnsupportedEncodingException;[m
[31m-import java.security.InvalidKeyException;[m
[31m-import java.security.KeyPair;[m
[31m-import java.security.KeyPairGenerator;[m
[31m-import java.security.KeyFactory;[m
[31m-import java.security.NoSuchAlgorithmException;[m
[31m-import java.security.NoSuchProviderException;[m
[31m-import java.security.PrivateKey;[m
[31m-import java.security.PublicKey;[m
[31m-import java.security.SecureRandom;[m
[31m-import java.security.Security;[m
[31m-import java.security.Signature;[m
[31m-import java.security.SignatureException;[m
[31m-import java.security.spec.InvalidKeySpecException;[m
[31m-import java.security.spec.PKCS8EncodedKeySpec;[m
[31m-import java.security.spec.X509EncodedKeySpec;[m
[31m-import java.util.Properties;[m
[31m-import java.util.logging.Level;[m
[31m-import java.util.logging.Logger;[m
[31m-import org.bouncycastle.jce.provider.BouncyCastleProvider;[m
[31m-[m
[31m-import sun.misc.BASE64Decoder;[m
[31m-import sun.misc.BASE64Encoder;[m
[31m-/**[m
[31m- * @author Illutionist[m
[31m- */[m
[31m-public class ECDSA {[m
[31m-    private static PublicKey publickey;[m
[31m-    private static PrivateKey privatekey;[m
[31m-    private static boolean generated = false;[m
[31m-    private static String fileName = "ECDSAconfig.properties";[m
[31m-    private static Properties prop = new Properties();    [m
[31m-    static {[m
[31m-        Security.addProvider(new BouncyCastleProvider());[m
[31m-    }[m
[31m-    /**[m
[31m-     * If already intialized, return public key. Otherwise generate public, private keys and then return public key [m
[31m-     * @return Public Key in bytes[m
[31m-     * @throws UnsupportedEncodingException [m
[31m-     */[m
[31m-    public static byte[] getPublicKey() throws UnsupportedEncodingException  {[m
[31m-        byte[] key = null;[m
[31m-        if (!generated) {[m
[31m-            initialize();[m
[31m-        }[m
[31m-        if (generated) key = publickey.getEncoded();[m
[31m-        return key;[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-     * If already initialized with public and private keys, sign[m
[31m-     * Otherwise, generate the properties and then sign[m
[31m-     * @param text Text to be signed[m
[31m-     * @return EC Signature in bytes [m
[31m-     */[m
[31m-    public static byte[] getSignature(String text)  {[m
[31m-        byte[] signature = null;[m
[31m-        String sign = "";[m
[31m-        if (!generated) {[m
[31m-            initialize();[m
[31m-        }[m
[31m-        if (generated){[m
[31m-                try { [m
[31m-                    Signature dsa = Signature.getInstance("SHA1withECDSA", "BC");[m
[31m-                    dsa.initSign(privatekey);[m
[31m-                    byte[] buf = text.getBytes("UTF-8");[m
[31m-                    dsa.update(buf, 0, buf.length);[m
[31m-                    signature = dsa.sign();[m
[31m-                    sign = new String(signature,"UTF-8");[m
[31m-                } catch (NoSuchAlgorithmException ex) {[m
[31m-                    Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-                } catch (NoSuchProviderException ex) {[m
[31m-                    Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-                } catch (InvalidKeyException ex) {[m
[31m-                    Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-                } catch (SignatureException ex) {[m
[31m-                    Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-                } catch (UnsupportedEncodingException ex) {[m
[31m-                Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-            }[m
[31m-        }[m
[31m-        return signature;[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-     * Ideally, private, public keys are generated in the first run and stored in a file[m
[31m-     * Subsequently, these are pulled from the file and utilized[m
[31m-     */[m
[31m-    public static void initialize() {[m
[31m-        try {[m
[31m-            File file = new File(fileName);[m
[31m-            if (!file.exists()) {[m
[31m-                file.createNewFile();              [m
[31m-                prop.load(new FileInputStream(file));[m
[31m-                generateProperties();[m
[31m-            }[m
[31m-            else {[m
[31m-                prop.load(new FileInputStream(file));[m
[31m-                pullProperties();[m
[31m-            }[m
[31m-        }[m
[31m-        catch (UnsupportedEncodingException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (NoSuchAlgorithmException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (NoSuchProviderException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (InvalidKeySpecException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (IOException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        }[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-     * Create the public, private keys using a random seed. These are stored in Base64 in properties file[m
[31m-     * @throws NoSuchAlgorithmException[m
[31m-     * @throws NoSuchProviderException[m
[31m-     * @throws UnsupportedEncodingException[m
[31m-     * @throws IOException [m
[31m-     */[m
[31m-    private static void generateProperties() throws NoSuchAlgorithmException, NoSuchProviderException, UnsupportedEncodingException, IOException {[m
[31m-        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");[m
[31m-        SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");[m
[31m-        keyGen.initialize(256, random);[m
[31m-        KeyPair pair = keyGen.generateKeyPair();[m
[31m-        privatekey = pair.getPrivate();[m
[31m-        publickey = pair.getPublic();[m
[31m-        BASE64Encoder encoder = new BASE64Encoder();[m
[31m-        String pri = encoder.encode(privatekey.getEncoded());[m
[31m-        String pub = encoder.encode(publickey.getEncoded());[m
[31m-        prop.setProperty("DSAprivatekey",pri);[m
[31m-        prop.setProperty("DSApublickey",pub);[m
[31m-        generated = true;[m
[31m-        prop.store(new FileOutputStream(fileName), null);[m
[31m-        [m
[31m-    }[m
[31m-    /**[m
[31m-     * Pull the Base64 encoded public and private keys from properties file[m
[31m-     * @throws UnsupportedEncodingException[m
[31m-     * @throws NoSuchAlgorithmException[m
[31m-     * @throws NoSuchProviderException[m
[31m-     * @throws InvalidKeySpecException[m
[31m-     * @throws IOException [m
[31m-     */[m
[31m-    private static void pullProperties() throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchProviderException, InvalidKeySpecException, IOException {[m
[31m-        String priv = prop.getProperty("DSAprivatekey");[m
[31m-        String publ = prop.getProperty("DSApublickey");[m
[31m-        BASE64Decoder decoder = new BASE64Decoder();[m
[31m-        byte[] pri= decoder.decodeBuffer(priv);[m
[31m-        byte[] pub = decoder.decodeBuffer(publ);[m
[31m-        PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(pri);[m
[31m-        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(pub);[m
[31m-        KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");[m
[31m-        privatekey =keyFactory.generatePrivate(priKeySpec);[m
[31m-        publickey =keyFactory.generatePublic(pubKeySpec);[m
[31m-        generated = true;[m
[31m-    }[m
[31m-    [m
[31m-    /**[m
[31m-     * Verify the signature against the data when public key is specified[m
[31m-     * @param data[m
[31m-     * @param signature[m
[31m-     * @param publicKey[m
[31m-     * @return the verification result[m
[31m-     * @return false in case of any exception[m
[31m-     */[m
[31m-    public static boolean verify(String data,byte[] signature,byte[] publicKey) {[m
[31m-        boolean verify = false;[m
[31m-        try {[m
[31m-            [m
[31m-            X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(publicKey);[m
[31m-            KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");[m
[31m-            PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);[m
[31m-            byte[] buf = data.getBytes("UTF-8");[m
[31m-            Signature sig = Signature.getInstance("SHA1withECDSA", "BC");[m
[31m-            sig.initVerify(pubKey);[m
[31m-            sig.update(buf, 0,buf.length);[m
[31m-            verify = sig.verify(signature);[m
[31m-        } catch (NoSuchAlgorithmException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (NoSuchProviderException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (InvalidKeySpecException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (InvalidKeyException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (SignatureException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        } catch (UnsupportedEncodingException ex) {[m
[31m-            Logger.getLogger(ECDSA.class.getName()).log(Level.SEVERE, null, ex);[m
[31m-        }[m
[31m-        return verify;[m
[31m-    }[m
[31m-}[m
[1mdiff --git a/src/freenet/io/BCSSLNetworkInterface.java b/src/freenet/io/BCSSLNetworkInterface.java[m
[1mdeleted file mode 100644[m
[1mindex eab94c7..0000000[m
[1m--- a/src/freenet/io/BCSSLNetworkInterface.java[m
[1m+++ /dev/null[m
[36m@@ -1,65 +0,0 @@[m
[31m-/*[m
[31m- * This program is free software; you can redistribute it and/or modify[m
[31m- * it under the terms of the GNU General Public License as published by[m
[31m- * the Free Software Foundation; either version 2 of the License, or[m
[31m- * (at your option) any later version.[m
[31m- *[m
[31m- * This program is distributed in the hope that it will be useful,[m
[31m- * but WITHOUT ANY WARRANTY; without even the implied warranty of[m
[31m- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the[m
[31m- * GNU General Public License for more details.[m
[31m- *[m
[31m- * You should have received a copy of the GNU General Public License[m
[31m- * along with this program; if not, write to the Free Software[m
[31m- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.[m
[31m- */[m
[31m-[m
[31m-package freenet.io;[m
[31m-/**[m
[31m-* Exactly same as SSLNetworkInterface[m
[31m-* Only renamed SSL by BCModifiedSSL through out the class[m
[31m-* This can be got rid off when BCSSL becomes the actual SSL[m
[31m-* i.e. when the changes in BCSSL are carried to SSL, this class would be worthless[m
[31m-*/[m
[31m-import freenet.crypt.BCModifiedSSL;[m
[31m-import java.io.IOException;[m
[31m-import java.net.ServerSocket;[m
[31m-import java.util.Arrays;[m
[31m-[m
[31m-import freenet.support.Executor;[m
[31m-import javax.net.ssl.SSLServerSocket;[m
[31m-[m
[31m-/**[m
[31m- * An SSL extension to the {@link NetworkInterface} [m
[31m- * @author ET[m
[31m- */[m
[31m-public class BCSSLNetworkInterface extends NetworkInterface {[m
[31m-	[m
[31m-	public static NetworkInterface create(int port, String bindTo, String allowedHosts, Executor executor, boolean ignoreUnbindableIP6) throws IOException {[m
[31m-		NetworkInterface iface = new BCSSLNetworkInterface(port, allowedHosts, executor);[m
[31m-		String[] failedBind = iface.setBindTo(bindTo, ignoreUnbindableIP6);[m
[31m-		if(failedBind != null) {[m
[31m-			System.err.println("Could not bind to some of the interfaces specified for port "+port+" : "+Arrays.toString(failedBind));[m
[31m-		}[m
[31m-		return iface;[m
[31m-	}[m
[31m-[m
[31m-	/**[m
[31m-	 * See {@link NetworkInterface}[m
[31m-	 */[m
[31m-	protected BCSSLNetworkInterface(int port, String allowedHosts, Executor executor) throws IOException {[m
[31m-		super(port, allowedHosts, executor);[m
[31m-	}[m
[31m-[m
[31m-	/**[m
[31m-	 * {@inheritDoc}[m
[31m-	 */[m
[31m-	@Override[m
[31m-	protected ServerSocket createServerSocket() throws IOException {[m
[31m-		SSLServerSocket serverSocket = (SSLServerSocket) BCModifiedSSL.createServerSocket();[m
[31m-		serverSocket.setNeedClientAuth(false);[m
[31m-		serverSocket.setUseClientMode(false);[m
[31m-		serverSocket.setWantClientAuth(false);[m
[31m-		return serverSocket;[m
[31m-	}[m
[31m-}[m
[1mdiff --git a/src/freenet/l10n/freenet.l10n.en.properties b/src/freenet/l10n/freenet.l10n.en.properties[m
[1mindex 595442b..778dae8 100644[m
[1m--- a/src/freenet/l10n/freenet.l10n.en.properties[m
[1m+++ b/src/freenet/l10n/freenet.l10n.en.properties[m
[36m@@ -169,8 +169,6 @@[m [mPageMaker.modeSimple=Simple interface[m
 PageMaker.modeSimpleTooltip=A simple interface all users can use[m
 PageMaker.modeAdvanced=Advanced interface[m
 PageMaker.modeAdvancedTooltip=An advanced interface that only experienced Freenet users and developers will need to use[m
[31m-ConfigToadlet.bcssl=Mobile App SSL[m
[31m-ConfigToadlet.darknetApp=Mobile App[m
 ConfigToadlet.node=Core settings[m
 ConfigToadlet.node.install=Installation settings[m
 ConfigToadlet.node.load=Load management[m
[36m@@ -185,8 +183,6 @@[m [mConfigToadlet.returnToNodeConfig=Return to configuration page[m
 ConfigToadlet.shortTitle=Configuration[m
 ConfigToadlet.ssl=SSL (restart required)[m
 ConfigToadlet.title=Freenet Node Configuration[m
[31m-ConfigToadlet.title.bcssl=SSL Settings for DarknetApp Communications [m
[31m-ConfigToadlet.title.darknetApp=Mobile App Settings [m
 ConfigToadlet.title.node=Configure core settings e.g. bandwidth usage[m
 ConfigToadlet.title.node.install=Installation settings, e.g. readonly program directory locations[m
 ConfigToadlet.title.node.load=Settings for controlling the amount of traffic through your Freenet node[m
[36m@@ -299,26 +295,13 @@[m [mDarknetAddRefToadlet.explainInstallerWindowsNotYet=Freenet has not yet managed t[m
 DarknetAddRefToadlet.explainInstallerNonWindows=You can find the latest non-Windows installer in ${filename} or click ${get-nonwindows}here${/get-nonwindows}. This is a jar file which must be opened with java; hopefully your friend can double click on it, but if that doesn't work try opening a command line and typing "java -jar ${shortfilename}".[m
 DarknetAddRefToadlet.explainInstallerNonWindowsNotYet=Freenet has not yet managed to download the non-Windows installer, however you can get it over Freenet ${link}here${/link}. This is a jar file which must be opened with java; hopefully your friend can double click on it, but if that doesn't work try opening a command line and typing "java -jar ${shortfilename}".[m
 DarknetAddRefToadlet.explainBox2=In order to connect to a Friend, you need to exchange noderefs with them. A noderef is a small file which contains the information needed for their copy of Freenet ("Freenet node") to connect to yours. You must add their noderef and they must add your noderef, for the two nodes to connect. See below for your noderef.[m
[31m-DarknetAppServer.newPeersCount=Newly added peers (Please don't change)[m
[31m-DarknetAppServer.newPeersCountLong=Newly added peers that are neither authorized nor rejected[m
[31m-DarknetAppServer.enabled=Enable synchronization with mobile app?[m
[31m-DarknetAppServer.enabledLong=Enable synchronization with mobile app?[m
[31m-DarknetAppServer.port=Port[m
[31m-DarknetAppServer.portLong=Port[m
[31m-DarknetAppServer.allowedHosts=Allowed Hosts[m
[31m-DarknetAppServer.allowedHostsLong=Allowed Hosts(default -->*<--)[m
[31m-DarknetAppServer.bindTo=Bind To [m
[31m-DarknetAppServer.bindToLong=Bind To (default -->0.0.0.0<--)[m
 DarknetConnectionsToadlet.addAnotherFriend=Add another Friend[m
 DarknetConnectionsToadlet.goFriendConnectionStatus=Go to the Friends page to see whether this friend connects[m
 DarknetConnectionsToadlet.activityTitle=Current Activity[m
 DarknetConnectionsToadlet.add=Add[m
[31m-DarknetConnectionsToadlet.addNew=Submit[m
[31m-DarknetConnectionsToadlet.addOpennetPeerTitle=Manually connect to a Stranger (not recommended!)[m
 DarknetConnectionsToadlet.addPeerTitle=Connect to a Friend[m
[32m+[m[32mDarknetConnectionsToadlet.addOpennetPeerTitle=Manually connect to a Stranger (not recommended!)[m
 DarknetConnectionsToadlet.alreadyInReferences=We already have the given reference.[m
[31m-DarknetConnectionsToadlet.auth=Authorize[m
[31m-DarknetConnectionsToadlet.AuthTitle=Add this peer as a friend[m
 DarknetConnectionsToadlet.backedOff=Connected but backed off: These peers are connected but we're backed off from them, so Freenet is not routing requests to them.[m
 DarknetConnectionsToadlet.backedOffShort=Backed off[m
 DarknetConnectionsToadlet.bracketedMoreDetailed=(more detailed)[m
[36m@@ -348,7 +331,6 @@[m [mDarknetConnectionsToadlet.foafReachableThroughTitle=Reachable Through[m
 DarknetConnectionsToadlet.connError=Connection failed (buggy node?)[m
 DarknetConnectionsToadlet.routingDisabled=Not routing traffic (we are currently connected to the node but we or it refuse to route traffic)[m
 DarknetConnectionsToadlet.routingDisabledShort=Not routing traffic[m
[31m-DarknetConnectionsToadlet.newPeersBoxTitle=Authorize new darknet peers[m
 DarknetConnectionsToadlet.noLoadStats=Don't know how many requests we can send so can't send any[m
 DarknetConnectionsToadlet.noLoadStatsShort=No load stats[m
 DarknetConnectionsToadlet.myName=Nickname for this node: ${name}[m
[36m@@ -394,7 +376,6 @@[m [mDarknetConnectionsToadlet.noVisibilityLevelAddingFriendTitle=You must set a visi[m
 DarknetConnectionsToadlet.noVisibilityLevelAddingFriend=You must set a visibility level for your friend - YES (your other friends can see them, provided they also have YES), NAME ONLY (they can see the name of the peer and offer to get connected if they know each other), or NO (your other friends cannot see this node). Making your friends visible to your friends improves performance and makes it easier to get connected both to Freenet and to people you know once you are on Freenet.[m
 DarknetConnectionsToadlet.opennetFnpPort=Opennet FNP: ${port}/UDP (used to connect to untrusted peers i.e. Strangers; forward this port if you can)[m
 DarknetConnectionsToadlet.pasteReference=Enter node reference directly:[m
[31m-DarknetConnectionsToadlet.peerNodeReference=Full Node Reference[m
 DarknetConnectionsToadlet.peersEnable=Enable selected peers[m
 DarknetConnectionsToadlet.peersDisable=Disable selected peers[m
 DarknetConnectionsToadlet.peersSetBurstOnly=On selected peers, set BurstOnly (only set this if you have a static IP and are not NATed and neither is the peer)[m
[36m@@ -464,7 +445,6 @@[m [mDarknetConnectionsToadlet.peerAdditionCode.CANT_PARSE=Can't parse[m
 DarknetConnectionsToadlet.peerAdditionCode.INTERNAL_ERROR=Internal error[m
 DarknetConnectionsToadlet.peerAdditionCode.INVALID_SIGNATURE=Invalid signature[m
 DarknetConnectionsToadlet.peerAdditionCode.ALREADY_IN_REFERENCE=Already added reference[m
[31m-DarknetConnectionsToadlet.reject=Discard[m
 DarknetConnectionsToadlet.resultName=Name of result[m
 DarknetConnectionsToadlet.numOfResults=Number of results[m
 DarknetConnectionsToadlet.visibilityTitle=Visible to friends?[m
[1mdiff --git a/src/freenet/node/Node.java b/src/freenet/node/Node.java[m
[1mindex cf6cfe2..f9195cf 100644[m
[1m--- a/src/freenet/node/Node.java[m
[1m+++ b/src/freenet/node/Node.java[m
[36m@@ -75,7 +75,6 @@[m [mimport freenet.crypt.ECDH;[m
 import freenet.crypt.EncryptingIoAdapter;[m
 import freenet.crypt.RandomSource;[m
 import freenet.crypt.Yarrow;[m
[31m-import freenet.darknetapp.DarknetAppServer;[m
 import freenet.io.comm.DMT;[m
 import freenet.io.comm.DisconnectedException;[m
 import freenet.io.comm.FreenetInetAddress;[m
[36m@@ -756,7 +755,7 @@[m [mpublic class Node implements TimeSkewDetectorCallback {[m
 	public final long startupTime;[m
 [m
 	private SimpleToadletServer toadlets;[m
[31m-	private DarknetAppServer darknetAppServer;[m
[32m+[m
 	public final NodeClientCore clientCore;[m
 [m
 	// ULPRs, RecentlyFailed, per node failure tables, are all managed by FailureTable.[m
[36m@@ -1043,11 +1042,6 @@[m [mpublic class Node implements TimeSkewDetectorCallback {[m
 [m
 		// FProxy config needs to be here too[m
 		SubConfig fproxyConfig = new SubConfig("fproxy", config);[m
[31m-		SubConfig darknetAppConfig = new SubConfig("darknetApp",config);[m
[31m-		//To Start DarknetAppServer[m
[31m-		darknetAppServer = new DarknetAppServer(darknetAppConfig, this, executor);[m
[31m-		darknetAppConfig.finishedInitialization();[m
[31m-		darknetAppServer.start();[m
 		try {[m
 			toadlets = new SimpleToadletServer(fproxyConfig, new ArrayBucketFactory(), executor, this);[m
 			fproxyConfig.finishedInitialization();[m
[36m@@ -2640,7 +2634,7 @@[m [mpublic class Node implements TimeSkewDetectorCallback {[m
 [m
 		registerNodeToNodeMessageListener(N2N_MESSAGE_TYPE_FPROXY, fproxyN2NMListener);[m
 		registerNodeToNodeMessageListener(Node.N2N_MESSAGE_TYPE_DIFFNODEREF, diffNoderefListener);[m
[31m-                [m
[32m+[m
 		// FIXME this is a hack[m
 		// toadlet server should start after all initialized[m
 		// see NodeClientCore line 437[m
[36m@@ -2650,9 +2644,6 @@[m [mpublic class Node implements TimeSkewDetectorCallback {[m
 			toadlets.removeStartupToadlet();[m
 		}[m
 [m
[31m-		if (darknetAppServer.isEnabled()) {[m
[31m-			darknetAppServer.finishStart();[m
[31m-		}[m
 		Logger.normal(this, "Node constructor completed");[m
 		System.out.println("Node constructor completed");[m
 	}[m
[1mdiff --git a/src/freenet/node/NodeStarter.java b/src/freenet/node/NodeStarter.java[m
[1mindex 22110aa..b8c7cfd 100644[m
[1m--- a/src/freenet/node/NodeStarter.java[m
[1m+++ b/src/freenet/node/NodeStarter.java[m
[36m@@ -16,7 +16,6 @@[m [mimport freenet.config.FreenetFilePersistentConfig;[m
 import freenet.config.InvalidConfigValueException;[m
 import freenet.config.PersistentConfig;[m
 import freenet.config.SubConfig;[m
[31m-import freenet.crypt.BCModifiedSSL;[m
 import freenet.crypt.DiffieHellman;[m
 import freenet.crypt.JceLoader;[m
 import freenet.crypt.RandomSource;[m
[36m@@ -188,8 +187,6 @@[m [mpublic class NodeStarter implements WrapperListener {[m
 		// Initialize SSL[m
 		SubConfig sslConfig = new SubConfig("ssl", cfg);[m
 		SSL.init(sslConfig);[m
[31m-		SubConfig bcsslConfig = new SubConfig("bcssl", cfg);[m
[31m-		BCModifiedSSL.init(bcsslConfig);[m
 [m
 		try {[m
 			node = new Node(cfg, null, null, logConfigHandler, this, executor);[m
